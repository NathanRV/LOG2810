package TP1;

import javafx.util.Pair;

import java.io.FileNotFoundException;
import java.util.*;

public class Driver {
    private Integer batteryLevel;
    private Queue<Customer> customers;
    private Queue<Customer> customersOnBoard;
    private WeightedGraph graph;
    private WeightedGraph.Node position;
    private LinkedList<WeightedGraph.Node> pathToDo;
    private LinkedList<WeightedGraph.Node> destinations;
    private LinkedList<WeightedGraph.Node> pathDone;

    public Driver(String graphFileName, String requeteFileName) throws FileNotFoundException {
        batteryLevel = 100;
        customers = new ArrayDeque<>();
        customersOnBoard = new ArrayDeque<>();
        graph = new WeightedGraph();
        graph.createGraph(graphFileName);
        initialiseDriver(requeteFileName);
        pathToDo = new LinkedList<>();
        destinations = new LinkedList<>();
        pathDone = new LinkedList<>();
    }

    /**
     * Public function that generates the customers recursively
     *
     * @param fileName information originating from txt file, in which each line represents either
     *                         information pertaining to node, or information pertaining to adjacentNodes
     */
    public void initialiseDriver(String fileName) throws FileNotFoundException {
        List<String> customerInformation = GeneralFunctions.readFile(fileName);
        initialiseDriver(customerInformation, 0);
    }

    /**
     * Private helper function that recursively process information generated by reading a text file and creates nodes, or
     * updates adjacentNodes attributes depending on the information read
     *
     * @param customerInformation list of either information pertaining to the creation of the node (index, hasBorne; size = 2)
     *                         or information pertaining to adjacentNodes (node, weight)
     *
     * @param lineNumber index of information
     */
    private void initialiseDriver(List<String> customerInformation, int lineNumber) {
        Map<Integer, WeightedGraph.Node> nodes = graph.getNodes();

        if (lineNumber == customerInformation.size()) {
            return;
        }
        String[] infoLine = customerInformation.get(lineNumber).split(",");
        if (infoLine.length == 1) { //first line of the txt file that contains the position of the driver
            position = nodes.get(Integer.parseInt(infoLine[0]));
            initialiseDriver(customerInformation, lineNumber + 1);
        }
        else if (infoLine.length == 4) {
            int index = Integer.parseInt(infoLine[0]); //number of the client
            WeightedGraph.Node sourceNode = nodes.get(Integer.parseInt(infoLine[1])); //node where the client is at
            WeightedGraph.Node destinationNode = nodes.get(Integer.parseInt(infoLine[2])); //node where the client wants to go
            int minutesWeight = Integer.parseInt(infoLine[3]); //time limit to get there
            Customer customer = new Customer(index, sourceNode, destinationNode, minutesWeight);
            customers.add(customer);
            initialiseDriver(customerInformation, lineNumber + 1);
        }
        else {
            initialiseDriver(customerInformation, lineNumber + 1);
        }
    }


    /**
     * TODO description
     *
     * @param TODO TODO
     * @return void
     */

    public void doAll() {
        while(customers.size() > 0 || !customersOnBoard.isEmpty()){
            nextAction();
            if(!destinations.isEmpty())
                nextDestination(); //move next node
        }
        printPathDone();
    }

    /**
     * Prints path followed
     *
     * @param None
     * @return void
     */
    public void printPathDone() {
        //Update Path distances
        Iterator<WeightedGraph.Node> itr = pathDone.iterator();
        WeightedGraph.Node current, prev = null;
        Integer distance = 0;
        while(itr.hasNext()){
            current = itr.next();
            if(current.getRecharge()){
                current.setDistance(prev.getDistance());
                continue;
            }
            if (prev != null && current != null) {
                distance += graph.computeShortestDistance(prev, current);
                current.setDistance(distance);
            }
            prev = current;
        }

        System.out.print("Trajet : ( ");
        for (WeightedGraph.Node node : pathDone) {
            if(node != null)
                System.out.print(node.getIndex() + " -> ");
            if(node.getRecharge())
                System.out.print("Recharge -> ");
            if(node.getClientDroppedOff() != Integer.MAX_VALUE)
                System.out.print("Debarquement client #" + node.getClientDroppedOff() + " -> ");
            /*if(node != null && node.getIndex() != 999)
                System.out.print(node.getIndex() + " ");
            else if(node.getIndex() == 999)
                System.out.print("Recharge ");*/
        }
        System.out.println(")");
        System.out.print("Total distance : ");
        System.out.println(pathDone.getLast().getDistance());

    }

    /**
     * Updates all attributes including destinations, nodes distance, pathToDo related to destinations
     *
     * @param Node destination node to be added
     * @return void
     */
    public void addDestinationLast(WeightedGraph.Node destination) {
        if(!destinations.isEmpty()) {
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(destinations.getLast(), destination);
            destinations.addLast(destination);
            //Distance to do in path already
            Integer distanceToAdd = pathToDo.getLast().getDistance();
            for (WeightedGraph.Node node : path) {
                node.setDistance(node.getDistance() + distanceToAdd);
                pathToDo.addLast(new WeightedGraph.Node(node));
            }
        }
        else{
            destinations.addLast(destination);
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(position, destination);
            pathToDo.addAll(path);
        }
    }

    /**
     * Updates all attributes related to destinations
     *
     * @param Node destination node to be added
     * @return void
     */
    public void addDestinationFirst(WeightedGraph.Node destination) {
        if(destination.getIndex() == destinations.getFirst().getIndex())
            return;
        if(!destinations.isEmpty()) {
            LinkedList<WeightedGraph.Node> normalPath = graph.plusCourtChemin(position, destinations.getFirst());
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(position, destination);
            LinkedList<WeightedGraph.Node> pathBack = graph.plusCourtChemin(destination, destinations.getFirst());
            destinations.addFirst(destination);
            //Remove nodes
            for(WeightedGraph.Node node : normalPath){
                pathToDo.remove();
            }
            //Distance to add to path
            Integer distanceToAdd = path.getLast().getDistance() + pathBack.getLast().getDistance();
            Integer distanceToRemove = normalPath.getLast().getDistance();
            Iterator<WeightedGraph.Node> itrBack = pathBack.descendingIterator();
            for (WeightedGraph.Node node : pathBack) {
                node.setDistance(node.getDistance() + path.getLast().getDistance());
            }
            for (WeightedGraph.Node node : pathToDo) {
                node.setDistance(node.getDistance() + distanceToAdd - distanceToRemove);
            }
            while(itrBack.hasNext()){
                WeightedGraph.Node node = itrBack.next();
                pathToDo.addFirst(node);
            }
            Iterator<WeightedGraph.Node> itr = path.descendingIterator();
            while(itr.hasNext()){
                WeightedGraph.Node node = itr.next();
                pathToDo.addFirst(node);
            }
        }
        else{
            destinations.addFirst(destination);
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(position, destination);
            path.poll();
            pathToDo.addAll(path);
        }
    }

    /**
     * Finds path to the node passed
     *
     * @param Node node to go to
     * @return Path as LinkedList
     */
    public LinkedList<WeightedGraph.Node> pathTo(WeightedGraph.Node node){
        LinkedList<WeightedGraph.Node> path = new LinkedList<>();
        for(WeightedGraph.Node n : pathToDo){
            path.addLast(n);
            if(n.getIndex() == node.getIndex())
                break;
        }

        return path;
    }

    /**
     * Detour path on path
     *
     * @param LinkedList path to find detour on
     * @return DetourPath as LinkedList
     */
    public Pair<LinkedList<WeightedGraph.Node>, LinkedList<WeightedGraph.Node>> detourPath(LinkedList<WeightedGraph.Node> path){
        Pair<WeightedGraph.Node, WeightedGraph.Node> pair = closestRechargeOnPath(path);
        WeightedGraph.Node prev = position, fork = pair.getKey();
        WeightedGraph.Node rechargeNode = pair.getValue();
        LinkedList<WeightedGraph.Node> forkPath, returnPath = null, detour;
        if(path.contains(fork)) {
            returnPath = graph.plusCourtChemin(rechargeNode, path.getLast());
        }
        forkPath = graph.plusCourtChemin(prev, rechargeNode);
        detour = forkPath;
        Integer distanceToRecharge = graph.computeDistanceOfPath(forkPath);
        for(WeightedGraph.Node node : returnPath){
            node.setDistance(node.getDistance() + distanceToRecharge);
            detour.addLast(node);
        }

        Pair<LinkedList<WeightedGraph.Node>, LinkedList<WeightedGraph.Node>> pairToReturn;
        pairToReturn = new Pair<>(forkPath, returnPath);

        return pairToReturn;
    }

    /**
     * Fork to destination
     *
     * @param Node source of fork
     * @param Node node to be added to path
     * @param Node destination to return
     * @return void
     */
    public LinkedList<WeightedGraph.Node> fork(WeightedGraph.Node source, WeightedGraph.Node fork, WeightedGraph.Node destination) {

        LinkedList<WeightedGraph.Node> testPath = new LinkedList<>(pathToDo);

        //Remove old path
        Iterator<WeightedGraph.Node> itr = testPath.listIterator();
        WeightedGraph.Node node = null;
        int insertIndex = 0;
        while(itr.hasNext()){
            node = itr.next();
            if(node.getIndex() == source.getIndex()){
                while (itr.hasNext() && node != destination) {
                    node = itr.next();
                    insertIndex = testPath.indexOf(node);
                    itr.remove();
                }
                break;
            }
        }

        LinkedList<WeightedGraph.Node> forkPathSource, forkReturnPath;
        forkPathSource = graph.plusCourtChemin(source, fork);
        forkReturnPath = graph.plusCourtChemin(fork, destination);

        LinkedList<WeightedGraph.Node> newPath = forkPathSource;
        for(WeightedGraph.Node nodeToAdd : forkReturnPath){
            newPath.addLast(nodeToAdd);
        }

        itr = newPath.descendingIterator();
        while(itr.hasNext()){
            node = itr.next();
            testPath.add(insertIndex, node);
        }

        return testPath;
    }


    /**
     * TODO description
     *
     * @param TODO TODO
     * @return void
     */
    public void nextAction() {
        Customer firstCust = customersOnBoard.peek(); //first customer to drop off
        while(!customersOnBoard.isEmpty() &&
                firstCust.destination.getIndex() == position.getIndex()){//if we're at the customers destination, drop off
            dropOff();
            firstCust = customersOnBoard.peek();
        }
        //if 4 customersOnBoard, return
        if(customersOnBoard.size() >= 4){
            return;
        }
        //if not 4 customersOnBoard, try picking up
        while (pickUp() && customersOnBoard.size() < 4) { }

        //if no more customers to pick up
        if(customers.isEmpty())
            return;

        if(destinations.isEmpty()) { //if no customers, get next customer
            if(pathDone.isEmpty() || !pathDone.getLast().equalsTo(position))
                pathDone.add(position);
            Customer customer = customers.peek();
            addDestinationLast(customer.source);
        }

        //Decision tree :
        /**
         * 1.customersOnBoard don't have time to pick up anyone without recharge
         * => drive
         * 2.customersOnBoard don't have time to pick up anyone with recharge
         * => drive
         * 3.customersOnBoard have time, but it isn't efficient to pick up before next destination
         * => drive
         * 4.customersOnBoard have time and it is efficient to pick up before next destination
         * => add pickUp spot as next destination
         *
         *  In other words : if(4){ add pick up} else {drive}
         *  check fork before next destination
         *  check efficiency
         *  check if recharges?
         *  ->
         *  check latestCustomer's time considering recharge
         *  check if nextCustomer's time enough for currentPath
         */

        Customer nextCust = customers.peek(); //next customer

        LinkedList<WeightedGraph.Node> forkPathSource, forkPathDestination, forkReturnPath, classicPath, normalPath;
        normalPath = graph.plusCourtChemin(position, destinations.getFirst());
        WeightedGraph.Node forkNodeSource = closestNodeOnPath(nextCust.source);
        LinkedList<WeightedGraph.Node> currentPath = new LinkedList<>();

        Iterator<WeightedGraph.Node> itr = pathToDo.iterator();
        WeightedGraph.Node node = null;
        while(itr.hasNext()){
            node = itr.next();
            if(node.getIndex() != destinations.getFirst().getIndex()) {
                currentPath.addLast(node);
            }
            else{
                break;
            }
        }

        //if fork isn't before next destination
        if(!currentPath.contains(forkNodeSource))
            return;

        forkPathSource = graph.plusCourtChemin(forkNodeSource, nextCust.source);
        forkReturnPath = graph.plusCourtChemin(nextCust.source, destinations.getFirst());
        forkPathDestination = graph.plusCourtChemin(destinations.getLast(), nextCust.destination);
        classicPath = graph.plusCourtChemin(nextCust.source, nextCust.destination);
        LinkedList<WeightedGraph.Node> pickUpPath = graph.plusCourtChemin(destinations.getLast(), nextCust.source);

        Integer normalDistance = normalPath.getLast().getDistance();
        Integer classicDistance = classicPath.getLast().getDistance();
        Integer pickUpDistance = pickUpPath.getLast().getDistance();
        Integer forkSourceDistance = forkPathSource.getLast().getDistance();
        Integer forkReturnDistance = forkReturnPath.getLast().getDistance();
        Integer forkDestinationDistance = forkPathDestination.getLast().getDistance();

        Integer forkDistance = forkSourceDistance + forkReturnDistance + forkDestinationDistance;
        Integer previousDistance = normalDistance + classicDistance + pickUpDistance;
        Integer changeDistance = forkDistance - previousDistance;

        //not shorter to fork
        if(changeDistance > 0)
            return;

        LinkedList<WeightedGraph.Node> destinationsCopy, destinationPath;
        destinationsCopy = new LinkedList<>(destinations);
        WeightedGraph.Node prev = position, next;
        Integer testBattery = batteryLevel;
        Integer timeForRecharges = 0;
        int j = destinations.size();
        for(int i = 1 ; i < j ; i++){
            next = destinationsCopy.poll();
            destinationPath = graph.plusCourtChemin(prev, next);
            if(testBattery.compareTo(destinationPath.getLast().getDistance()) < 15){ //need to charge
                destinations.add(destinations.indexOf(next), closestRechargeOnPath(destinationPath).getValue());

                Pair<LinkedList<WeightedGraph.Node>, LinkedList<WeightedGraph.Node>> detourPair = detourPath(destinationPath);
                LinkedList<WeightedGraph.Node> forkPath = detourPair.getKey();
                LinkedList<WeightedGraph.Node> returnPath = detourPair.getValue();

                Integer distanceBack = returnPath.getLast().getDistance();

                Integer changeInDistance = forkPath.getLast().getDistance()
                        + returnPath.getLast().getDistance() - currentPath.getLast().getDistance();

                testBattery = 100;
                testBattery -= distanceBack;
                //10 for recharge, time for detour - time normal
                timeForRecharges += (10 + changeInDistance);
            }
            else {
                testBattery -= (next.getDistance() - prev.getDistance());
            }
            prev = next;
        }

        Integer totalTimeAdded = pathToDo.getLast().getDistance() + changeDistance + timeForRecharges;
        Integer totalTimeForNext = totalTimeAdded - forkSourceDistance; //minus time to get to source

        //Time for next customer
        if(nextCust.time.compareTo(totalTimeForNext) < 0)
            return;

        //Time for customers on board
        for(Customer customer : customersOnBoard){
            if(customer.time.compareTo(totalTimeAdded) < 0)
                return;
        }

        //if passed all test add pick up
        addDestinationFirst(nextCust.source);
    }

    /**
     * Finds closest recharge on path
     *
     * @param path path of the nodes
     * @return recharge node closest on path
     */

    public Pair<WeightedGraph.Node, WeightedGraph.Node> closestRechargeOnPath(LinkedList<WeightedGraph.Node> path) {
        //Current position
        if(position.getBorne()){
            Pair<WeightedGraph.Node, WeightedGraph.Node> pair = new Pair<WeightedGraph.Node, WeightedGraph.Node>(position, position);
            return pair;
        }

        WeightedGraph.Node closestRechargeOverall = closestRecharge(position);
        WeightedGraph.Node forkNode = null;
        WeightedGraph.Node closestRecharge;
        Integer closestDistance = graph.computeShortestDistance(position, closestRechargeOverall);
        for(WeightedGraph.Node node : path){
            closestRecharge = closestRecharge(node);
            int distanceToRecharge = graph.computeShortestDistance(node, closestRecharge);
            if(node.getDistance() + distanceToRecharge + 15 > batteryLevel) //stop when too far
                break;
            if(distanceToRecharge < closestDistance){
                closestDistance = distanceToRecharge;
                closestRechargeOverall = closestRecharge;
                forkNode = node;
            }
        }
        Pair<WeightedGraph.Node, WeightedGraph.Node> pair = new Pair<WeightedGraph.Node, WeightedGraph.Node>(forkNode, closestRechargeOverall);
        return pair;
    }

    /**
     * TODO description
     *
     * @param source source node
     * @return recharge node
     *
     */
    public WeightedGraph.Node closestRecharge(WeightedGraph.Node source) {
        return closestRecharge(source.getIndex());
    }

    /**
     * TODO description
     *
     * @param indexSource index of the source node
     * @return recharge node
     *
     */
    public WeightedGraph.Node closestRecharge(int indexSource) {
        LinkedList<WeightedGraph.Node> shortestPath = null;
        Integer shortestDistance;
        shortestDistance = Integer.MAX_VALUE;
        Map<Integer, WeightedGraph.Node> nodeMap = graph.getNodes();

        for(Map.Entry<Integer, WeightedGraph.Node> nodeEntry : nodeMap.entrySet()){
            WeightedGraph.Node node = nodeEntry.getValue();
            if(node.getBorne()){
                if(graph.computeShortestDistance(indexSource, node.getIndex()) < shortestDistance){
                    shortestPath = graph.plusCourtChemin(indexSource, node.getIndex());
                    shortestDistance = graph.computeDistanceOfPath(shortestPath);
                }
            }
        }

        return shortestPath.getLast();
    }

    /**
     * Finds the closest node on path from node passed
     *
     * @param path path of the nodes
     * @param destination node which we want to go to
     * @return node closest on path
     */
    public WeightedGraph.Node closestNodeOnPath(WeightedGraph.Node destination) {
        WeightedGraph.Node forkNode = null;
        Integer closestDistance = Integer.MAX_VALUE;
        for(WeightedGraph.Node node : pathToDo){
            int distanceToNode = graph.computeShortestDistance(node, destination);
            if(distanceToNode < closestDistance){
                closestDistance = distanceToNode;
                forkNode = node;
            }
        }
        return forkNode;
    }

    /**
     * TODO description
     *
     * @param indexSource index of the source node
     * @return recharge node
     *
     */

    public void recharge() {
        if(position.getBorne()){
            position.setRecharge(true);
            batteryLevel = 100;
            for (Customer customer : customersOnBoard){
                //+10 minutes au trajet
                customer.time -= 10;
            }
            //TODO
/*
            WeightedGraph.Node rechargeNode = new WeightedGraph.Node(999, true);
            pathDone.addLast(rechargeNode);
*/
        }
    }


    /**
     * Drops off first arrived customer, if at right destination
     *
     * @param indexSource index of the source node
     * @return void
     *
     */
    public void dropOff(){
        Customer customer = customersOnBoard.peek();
        if(customer != null && customer.destination.getIndex() == position.getIndex()){
            position.setClientDroppedOff(customer.index);
            customersOnBoard.remove(customer);
        }
    }

    /**
     * Adds a customer to the customersOnBoard queue only if
     * the customer is already at the driver's position
     *
     * @return boolean of whether a customer was picked up or not
     */
    public boolean pickUp() {
        if(!customers.isEmpty()) {
            Customer nextCustomer = customers.peek();
            if (position.getIndex() == nextCustomer.source.getIndex()) {
                if(!customersOnBoard.isEmpty()) {
                    Customer lastCustomer = null;
                    for (Customer customer : customersOnBoard) {
                        lastCustomer = customer;
                    }
                    if (lastCustomer.source.equalsTo(position))
                        pathDone.addLast(position);
                }
                customersOnBoard.add(customers.poll());
                addDestinationLast(nextCustomer.destination);
                return true;
            }
        }
        return false;
    }

    //TODO
    public void nextDestination() {
        goTo(destinations.getFirst());
    }

    /**TODO
     * Driver class for recursive function
     *
     * @param None
     * @return void
     */
    private void goTo(WeightedGraph.Node destination) {
        goTo(destination.getIndex());
    }

    //TODO
    private void goTo(int destinationIndex) {
        LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(position.getIndex(), destinationIndex);
        int distance = graph.computeDistanceOfPath(path);
        WeightedGraph.Node destination = path.getLast();
        WeightedGraph.Node rechargeDest = closestRecharge(destination);
        int distDestRecharge = graph.computeShortestDistance(destination, rechargeDest);
        //distance to destination + distance from destination to closest recharge
        int totalDist = distance + distDestRecharge;
        if (batteryLevel - totalDist < 15) { //if not enough battery
            Pair<WeightedGraph.Node, WeightedGraph.Node> pair;
            WeightedGraph.Node recharge;
            pair = closestRechargeOnPath(path);
            recharge = pair.getValue();
            addDestinationFirst(recharge);
            goTo(recharge); //goTo closest recharge on path
            //recursive call until distance short enough for battery
            if(batteryLevel != 100){ //if first recharge
                recharge();
                //update path from recharge
                path = graph.plusCourtChemin(position.getIndex(), destinationIndex);
            }
        }
        if (batteryLevel - totalDist >= 15 && //check not battery too low
                (destinations.getFirst().getIndex() == destination.getIndex() || batteryLevel != 100)
                //destination is next in destinations or battery not full
                ) {
            batteryLevel -= distance;
            for(Customer customer : customersOnBoard){
                customer.time -= distance;
            }
            for(WeightedGraph.Node node : path){
                if(!pathToDo.getFirst().equalsTo(pathDone.getLast()))
                    pathDone.addLast(pathToDo.poll());
                else
                    pathToDo.poll();
            }
            for(WeightedGraph.Node node : pathToDo){
                node.setDistance(node.getDistance() - distance);
            }
            position = destinations.poll();//destination;
        }
    }

    static class Customer {
        private WeightedGraph.Node source;
        private WeightedGraph.Node destination;
        private Integer time;
        private int index;

        public Customer(int index, WeightedGraph.Node source, WeightedGraph.Node destination, Integer time) {
            this.index = index;
            this.destination = destination;
            this.source = source;
            this.time = time;
        }

        public void decrementTime(int timeSpent) { time -= timeSpent; }

        public Integer getTime() { return this.time; }

        public WeightedGraph.Node getSource() { return this.source; }

        public WeightedGraph.Node getDestination() { return this.destination; }

    }
}

