package TP1;

import javafx.util.Pair;

import java.io.FileNotFoundException;
import java.util.*;

public class Driver {
    //car's battery level from 0 to 100
    private Integer batteryLevel;
    //list of all the customers on requetes.txt that the driver has not picked up
    private Queue<Customer> customers;
    //customers the driver is serving, max size of 4 at a time
    private Queue<Customer> customersOnBoard;
    //map of all the neighborhoods
    private WeightedGraph graph;
    //current position of the driver
    private WeightedGraph.Node currentPos;
    //path the driver needs to follow
    private LinkedList<WeightedGraph.Node> pathToDo;
    //destinations the driver can and has to get to
    private LinkedList<WeightedGraph.Node> destinations;
    //path the driver has driven on
    private LinkedList<WeightedGraph.Node> pathDone;
    //output on interface of the full trajectory
    private String traiterRequetesOutput = "Trajet : \n";

    public Driver(String graphFileName, String requeteFileName) throws FileNotFoundException {
        batteryLevel = 100;
        customers = new ArrayDeque<>();
        customersOnBoard = new ArrayDeque<>();
        graph = new WeightedGraph();
        graph.createGraph(graphFileName);
        initialiseDriver(requeteFileName);
        pathToDo = new LinkedList<>();
        destinations = new LinkedList<>();
        pathDone = new LinkedList<>();
    }

    /**
     * Public function that generates the customers recursively
     *
     * @param fileName information originating from txt file, in which each line represents either
     *                         information regarding the node, or information regarding adjacentNodes
     */
    public void initialiseDriver(String fileName) throws FileNotFoundException {
        List<String> customerInformation = GeneralFunctions.readFile(fileName);
        initialiseDriver(customerInformation, 0);
    }

    /**
     * Private helper function that recursively process information generated by reading a text file and creates nodes, or
     * updates adjacentNodes attributes depending on the information read
     *
     * @param customerInformation list of either information pertaining to the creation of the node (index, hasBorne; size = 2)
     *                         or information pertaining to adjacentNodes (node, weight)
     *
     * @param lineNumber index of information
     *
     */
    private void initialiseDriver(List<String> customerInformation, int lineNumber) {
        Map<Integer, WeightedGraph.Node> nodes = graph.getNodes();

        if (lineNumber == customerInformation.size()) {
            return;
        }
        String[] infoLine = customerInformation.get(lineNumber).split(",");
        if (infoLine.length == 1) { //first line of the txt file that contains the position of the driver
            currentPos = nodes.get(Integer.parseInt(infoLine[0]));
            initialiseDriver(customerInformation, lineNumber + 1);
        }
        else if (infoLine.length == 4) {
            int index = Integer.parseInt(infoLine[0]); //number of the client
            WeightedGraph.Node sourceNode = nodes.get(Integer.parseInt(infoLine[1])); //node where the client is at
            WeightedGraph.Node destinationNode = nodes.get(Integer.parseInt(infoLine[2])); //node where the client wants to go
            int minutesWeight = Integer.parseInt(infoLine[3]); //time limit to get there
            Customer customer = new Customer(index, sourceNode, destinationNode, minutesWeight);
            customers.add(customer);
            initialiseDriver(customerInformation, lineNumber + 1);
        }
        else {
            initialiseDriver(customerInformation, lineNumber + 1);
        }
    }


    /**
     * Public function that finds the shortest path to serve as many customers in their respective time limit
     * all while maintaining a battery percentage of over 15%
     *
     * @return String of shortest path
     *
     */

    public String traiterRequetes() {
        while(customers.size() > 0 || !customersOnBoard.isEmpty()){
            queueCustomersDestination();
            if(!destinations.isEmpty())
                goToNextDestination(); //move next node
        }
        traiterRequetesOutput += "\nFin du trajet";
        updateTotalDistances();
        traiterRequetesOutput += "\n\nCharge de la batterie : " + batteryLevel;
        return traiterRequetesOutput;
    }

    /**
     * Public function that calculates the total distance of the path followed by the driver to serve
     * all the customers
     *
     */

    public void updateTotalDistances(){
        Iterator<WeightedGraph.Node> itr = pathDone.iterator();
        WeightedGraph.Node current, prev = null;
        int distance = 0;

        while(itr.hasNext()){
            current = itr.next();
            if (prev != null) {
                distance += graph.computeShortestDistance(prev, current);
                current.setDistance(distance);
            }
            prev = current;
        }
        traiterRequetesOutput += "\n\nDistance totale : " + pathDone.getLast().getDistance();
    }

    /**
     * Public function that adds path information to output string
     *
     * @param index corresponds to either the index of the customer or of the node
     * @param state according to state, printPath adds the appropriate string to output
     *
     */

    public void printPath(int index, String state) {
        switch (state) {
            case "path" :
                traiterRequetesOutput += index + " -> ";
                break;
            case "pickup" :
                traiterRequetesOutput += "Embarquement client #" + index + " -> \n";
                break;
            case "recharge" :
                traiterRequetesOutput += "Recharge -> \n";
                break;
            case "dropoff":
                traiterRequetesOutput += "Debarquement client #" + index + " -> \n";
                break;
        }
    }

    /**
     * Public function that updates all attributes including destinations, nodes distance and pathToDo
     * and adds the node to destinations list at the last position
     *
     * @param destination node to be added last in destinations list
     */
    public void addDestinationLast(WeightedGraph.Node destination) {
        if(!destinations.isEmpty()) {
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(destinations.getLast(), destination);
            destinations.addLast(destination);
            //adding the node.getDistance which corresponds to the distance from path's first node to node
            //to oldDistance which corresponds to the distance from the first to the last node on pathToDo
            Integer oldDistance = pathToDo.getLast().getDistance();
            for (WeightedGraph.Node node : path) {
                node.setDistance(node.getDistance() + oldDistance);
                pathToDo.addLast(new WeightedGraph.Node(node));
            }
        }
        else {
            destinations.addLast(destination);
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(currentPos, destination);
            pathToDo.addAll(path);
        }
    }

    /**
     *
     *
     */
    public void removeDestinationLast() {
        WeightedGraph.Node destination = destinations.getLast();
        if (destination == null)
            return;

        //removes last destination
        destinations.removeLast();

        if(!destinations.isEmpty()) {
            //path from second to last destination to the last destination
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(destinations.peekLast(), destination);
            for (WeightedGraph.Node node : path) {
                pathToDo.removeLast();
            }
        }
        else {
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(currentPos, destination);
            for (WeightedGraph.Node node : path) {
                pathToDo.removeLast();
            }
        }

    }

    /**
     * Public function that updates all attributes including destinations, nodes distance, pathToDo related to destinations
     * and adds the node to destinations list at the last position
     *
     * @param destination node to be added first in destinations list
     */
    public void addDestinationFirst(WeightedGraph.Node destination) {
        if(destination.getIndex() == destinations.getFirst().getIndex())
            return;
        if(!destinations.isEmpty()) {
            LinkedList<WeightedGraph.Node> normalPath = graph.plusCourtChemin(currentPos, destinations.getFirst());
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(currentPos, destination);
            LinkedList<WeightedGraph.Node> pathBack = graph.plusCourtChemin(destination, destinations.getFirst());

            destinations.addFirst(destination);

            for(WeightedGraph.Node node : normalPath){
                pathToDo.remove();
            }

            Integer distanceToAdd = path.getLast().getDistance() + pathBack.getLast().getDistance();
            Integer distanceToRemove = normalPath.getLast().getDistance();
            Iterator<WeightedGraph.Node> itrBack = pathBack.descendingIterator();

            for (WeightedGraph.Node node : pathBack) {
                node.setDistance(node.getDistance() + path.getLast().getDistance());
            }
            for (WeightedGraph.Node node : pathToDo) {
                node.setDistance(node.getDistance() + distanceToAdd - distanceToRemove);
            }
            while(itrBack.hasNext()){
                WeightedGraph.Node node = itrBack.next();
                pathToDo.addFirst(node);
            }
            Iterator<WeightedGraph.Node> itr = path.descendingIterator();
            while(itr.hasNext()){
                WeightedGraph.Node node = itr.next();
                pathToDo.addFirst(node);
            }
        }
        else {
            destinations.addFirst(destination);
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(currentPos, destination);
            path.poll();
            pathToDo.addAll(path);
        }
    }


    /**
     * Public function that determines a detour path to a recharging station on path
     *
     * @param path path to find detour on
     *
     * @return Pair<LinkedList<WeightedGraph.Node>, LinkedList<WeightedGraph.Node>>
     *     of the detour path from current position to recharge node
     *      and the return path from recharge node to path's last node
     *
     */

    public Pair<LinkedList<WeightedGraph.Node>, LinkedList<WeightedGraph.Node>> detourPath(LinkedList<WeightedGraph.Node> path){
        Pair<WeightedGraph.Node, WeightedGraph.Node> pair = closestRechargeToPath(path);
        WeightedGraph.Node prev = currentPos, fork = pair.getKey();
        WeightedGraph.Node rechargeNode = pair.getValue();
        LinkedList<WeightedGraph.Node> forkPath, returnPath = null, detour;

        if(path.contains(fork))
            returnPath = graph.plusCourtChemin(rechargeNode, path.getLast());

        forkPath = graph.plusCourtChemin(prev, rechargeNode);
        detour = forkPath;
        int distanceToRecharge = graph.computeDistanceOfPath(forkPath);
        if (returnPath != null) {
            for(WeightedGraph.Node node : returnPath){
                node.setDistance(node.getDistance() + distanceToRecharge);
                detour.addLast(node);
            }
        }

        Pair<LinkedList<WeightedGraph.Node>, LinkedList<WeightedGraph.Node>> pairToReturn;
        pairToReturn = new Pair<>(forkPath, returnPath);

        return pairToReturn;
    }

    /**
     * Public function that adds destinations of customers on board considering
     * time effectiveness, the car's battery and serving as many customers as possible
     *
     */
    public void queueCustomersDestination() {

        Customer firstCustomer = customersOnBoard.peek();

        //if we're at the customers destination, drop off
        while(!customersOnBoard.isEmpty() &&
                firstCustomer.destination.getIndex() == currentPos.getIndex()) {
            dropOff();
            firstCustomer = customersOnBoard.peek();
        }

        //if 4 customersOnBoard, return
        if(customersOnBoard.size() >= 4){
            return;
        }

        //if not 4 customersOnBoard, try to pickUp
        while(pickUp() && customersOnBoard.size() < 4) {}

        //while next customers time is finished, "dispatch to other drivers"
        while(!customers.isEmpty() && customers.peek().time <= 0) {
            customers.poll();
            return;
        }

        //if no more customers to pick up, return
        if(customers.isEmpty())
            return;

        //if nowhere to go, get next customer
        if(destinations.isEmpty()) {
            if(pathDone.isEmpty() || !pathDone.getLast().equalsTo(currentPos)) {
                pathDone.add(currentPos);
                printPath(currentPos.getIndex(), "path");
            }
            //adding customer's source to destinations so we can see if the driver can pick him up
            if (customers.peek() != null) {
                addDestinationLast(customers.peek().source);
            }
        }

        /* Decision tree :
         * 1.customersOnBoard don't have time to pick up anyone without recharge
         * => drive
         * 2.customersOnBoard don't have time to pick up anyone with recharge
         * => drive
         * 3.customersOnBoard have time, but it isn't efficient to pick up before next destination
         * => drive
         * 4.customersOnBoard have time and it is efficient to pick up before next destination
         * => add pickUp spot as next destination
         *
         *  In other words : if(4){ add pick up} else {drive}
         *  check fork before next destination
         *  check efficiency
         *  check if recharge needed
         *  ->
         *  check latestCustomer's time considering recharge
         *  check if nextCustomer's time enough for currentPath
         */
        Customer nextCustomer = customers.peek();


        /*verifying that forkSourceNode is before the first destination in pathToDo */

        //forkSourceNode: closest node on pathToDo to the next customer's current position
        WeightedGraph.Node forkSourceNode = closestNodeOnPath(nextCustomer.source);

        //currentPath: adding all of pathToDo's nodes to currentPath up until we find the destinations node
        LinkedList<WeightedGraph.Node> currentPath = new LinkedList<>();
        WeightedGraph.Node node;

        for (WeightedGraph.Node value : pathToDo) {
            node = value;
            if (node.getIndex() != destinations.getFirst().getIndex()) {
                currentPath.addLast(node);
            } else {
                break;
            }
        }

        //if forkSourceNode is not in currentPath, then it's placed after the first destination,
        // remove the customer's source off of destinations and return
        if(!currentPath.contains(forkSourceNode)) {
            //removeDestinationLast();
            return;
        }


        /*verify that the forkPath is shorter than the originalPath*/

        //normalPath: nodes of shortest path between driver's current position and the first destination node
        LinkedList<WeightedGraph.Node> normalPath = graph.plusCourtChemin(currentPos, destinations.getFirst());
        //classicPath: nodes of shortest path between nextCustomer's current position and his destination node
        LinkedList<WeightedGraph.Node> classicPath = graph.plusCourtChemin(nextCustomer.source, nextCustomer.destination);
        //pickUpPath: nodes of shortest path between the last destination node and nextCustomer's current position
        LinkedList<WeightedGraph.Node> pickUpPath = graph.plusCourtChemin(destinations.getLast(), nextCustomer.source);

        //forkSourcePath: nodes of shortest path between forkSourceNode and nextCustomer's current position
        LinkedList<WeightedGraph.Node> forkSourcePath = graph.plusCourtChemin(forkSourceNode, nextCustomer.source);
        //forkDestinationPath: nodes of shortest path between forkSourceNode and nextCustomer's destination
        LinkedList<WeightedGraph.Node> forkDestinationPath = graph.plusCourtChemin(destinations.getLast(), nextCustomer.destination);
        //forkReturnPath: nodes of shortest path between nextCustomer's current position and the first destination node
        LinkedList<WeightedGraph.Node> forkReturnPath = graph.plusCourtChemin(nextCustomer.source, destinations.getFirst());

        Integer normalDistance = normalPath.getLast().getDistance();
        Integer classicDistance = classicPath.getLast().getDistance();
        Integer pickUpDistance = pickUpPath.getLast().getDistance();

        Integer forkSourceDistance = forkSourcePath.getLast().getDistance();
        Integer forkReturnDistance = forkReturnPath.getLast().getDistance();
        Integer forkDestinationDistance = forkDestinationPath.getLast().getDistance();

        Integer forkDistance = forkSourceDistance + forkReturnDistance + forkDestinationDistance;
        Integer originalDistance = normalDistance + classicDistance + pickUpDistance;
        Integer changeDistance = forkDistance - originalDistance;

        //if the original distance is shorter than the fork distance,
        //remove the customer's source off of destinations return
        if(changeDistance > 0) {
            //removeDestinationLast();
            return;
        }

        /* verify when recharge is needed */

        LinkedList<WeightedGraph.Node> destinationsCopy, destinationPath;
        destinationsCopy = new LinkedList<>(destinations);
        WeightedGraph.Node prev = currentPos, next;
        Integer batteryCopy = batteryLevel;
        Integer timeForRecharges = 0;

        int destinationsSize = destinations.size();
        for(int i = 1 ; i < destinationsSize; i++){
            next = destinationsCopy.poll();
            destinationPath = graph.plusCourtChemin(prev, next);
            if(batteryCopy.compareTo(destinationPath.getLast().getDistance()) < 15){ //need to charge
                destinations.add(destinations.indexOf(next), closestRechargeToPath(destinationPath).getValue());

                Pair<LinkedList<WeightedGraph.Node>, LinkedList<WeightedGraph.Node>> detourPair = detourPath(destinationPath);
                LinkedList<WeightedGraph.Node> forkPath = detourPair.getKey();
                LinkedList<WeightedGraph.Node> returnPath = detourPair.getValue();

                int distanceBack = returnPath.getLast().getDistance();

                int changeInDistance = forkPath.getLast().getDistance()
                        + returnPath.getLast().getDistance() - currentPath.getLast().getDistance();

                batteryCopy = 100;
                batteryCopy -= distanceBack;
                //10 for recharge, time for detour - time normal
                timeForRecharges += (10 + changeInDistance);
            }
            else {
                batteryCopy -= (next.getDistance() - prev.getDistance());
            }
            prev = next;
        }

        Integer totalTimeAdded = pathToDo.getLast().getDistance() + changeDistance + timeForRecharges;
        Integer totalTimeForNext = totalTimeAdded - forkSourceDistance; //minus time to get to source

        //if time to get to next customer's goes over his time limit, return
        if(nextCustomer.time.compareTo(totalTimeForNext) < 0) {
            //removeDestinationLast();
            return;
        }
        //if time to get to next customer on board goes over his time limit, return
        for(Customer customer : customersOnBoard){
            if(customer.time.compareTo(totalTimeAdded) < 0) {
                //removeDestinationLast();
                return;
            }
        }

        //if passed all test, add pick up
        //addDestinationFirst(nextCustomer.source);
    }

    /**
     * Finds closest recharge node to the path
     *
     * @param path path of the nodes
     * @return pair of fork node to get to recharge node and recharge node closest to the path
     */

    public Pair<WeightedGraph.Node, WeightedGraph.Node> closestRechargeToPath(LinkedList<WeightedGraph.Node> path) {
        if(currentPos.getBorne())
            return new Pair<>(currentPos, currentPos);

        WeightedGraph.Node closestRechargeOverall = closestRecharge(currentPos);
        WeightedGraph.Node forkNode = null;
        WeightedGraph.Node closestRecharge;
        int closestDistance = graph.computeShortestDistance(currentPos, closestRechargeOverall);

        for(WeightedGraph.Node node : path){
            closestRecharge = closestRecharge(node);
            int distanceToRecharge = graph.computeShortestDistance(node, closestRecharge);
            if(node.getDistance() + distanceToRecharge + 15 > batteryLevel) //stop when too far for the battery
                break;
            if(distanceToRecharge < closestDistance){
                closestDistance = distanceToRecharge;
                closestRechargeOverall = closestRecharge;
                forkNode = node;
            }
        }
        return new Pair<>(forkNode, closestRechargeOverall);
    }

    /**
     * Public function that finds the closest recharge node to source node
     *
     * @param source node to find closest recharge to
     * @return recharge node closest to source
     *
     */
    public WeightedGraph.Node closestRecharge(WeightedGraph.Node source) {
        return closestRecharge(source.getIndex());
    }

    /**
     * Private helper function that finds the closest recharge node to source node
     *
     * @param indexSource index of the source node to find closest recharge to
     * @return recharge node closest to source
     *
     */
    private WeightedGraph.Node closestRecharge(int indexSource) {
        LinkedList<WeightedGraph.Node> shortestPath = null;
        int shortestDistance;
        shortestDistance = Integer.MAX_VALUE;
        Map<Integer, WeightedGraph.Node> nodeMap = graph.getNodes();

        for(Map.Entry<Integer, WeightedGraph.Node> nodeEntry : nodeMap.entrySet()){
            WeightedGraph.Node node = nodeEntry.getValue();
            if(node.getBorne()){
                if(graph.computeShortestDistance(indexSource, node.getIndex()) < shortestDistance){
                    shortestPath = graph.plusCourtChemin(indexSource, node.getIndex());
                    shortestDistance = graph.computeDistanceOfPath(shortestPath);
                }
            }
        }

        return shortestPath.getLast();
    }

    /**
     * Public function that finds the closest node on path to destination node
     *
     * @param destination node which we want to go to
     * @return node closest on path to destination
     *
     */
    public WeightedGraph.Node closestNodeOnPath(WeightedGraph.Node destination) {
        WeightedGraph.Node forkNode = null;
        int closestDistance = Integer.MAX_VALUE;
        for(WeightedGraph.Node node : pathToDo){
            int distanceToNode = graph.computeShortestDistance(node, destination);
            if(distanceToNode < closestDistance){
                closestDistance = distanceToNode;
                forkNode = node;
            }
        }
        return forkNode;
    }

    /**
     * Public function that recharges the car's battery
     *
     */

    public void recharge() {
        if(currentPos.getBorne()){
            printPath(currentPos.getIndex(), "recharge");
            batteryLevel = 100;
            //substract time of recharge (10 minutes) to client's time
            for (Customer customer : customersOnBoard){
                customer.time -= 10;
            }
            for (Customer customer : customers){
                customer.time -= 10;
            }
        }
    }


    /**
     * Public function that removes a customer to the customersOnBoard queue only if
     * the customer is already at the driver's position
     *
     *
     */
    public void dropOff(){
        Customer customer = customersOnBoard.peek();
        if(customer != null && customer.destination.getIndex() == currentPos.getIndex()){
            printPath(customer.index, "dropoff");
            customersOnBoard.remove(customer);
        }
    }

    /**
     * Adds a customer to the customersOnBoard queue only if
     * the customer is already at the driver's position
     *
     * @return boolean of whether a customer was picked up or not
     *
     */
    public boolean pickUp() {
        if(!customers.isEmpty()) {
            Customer nextCustomer = customers.peek();
            if (currentPos.getIndex() == nextCustomer.source.getIndex()) {
                if(!customersOnBoard.isEmpty()) {
                    Customer lastCustomer = null;
                    lastCustomer = customersOnBoard.element();
                    for (Customer customer : customersOnBoard) {
                        lastCustomer = customer;
                    }
                    if (lastCustomer.source.equalsTo(currentPos) && !pathDone.getLast().equalsTo(currentPos)) {
                        pathDone.addLast(currentPos);
                        printPath(currentPos.getIndex(), "path");
                    }
                }
                customersOnBoard.add(customers.poll());
                printPath(nextCustomer.index, "pickup");
                addDestinationLast(nextCustomer.destination);
                return true;
            }
        }
        return false;
    }

    /**
     * Public function that calls goTo function with the first destination to go to
     *
     */
    public void goToNextDestination() {
        if(destinations.getFirst() == null)
            return;
        goTo(destinations.getFirst());
    }

    /**
     * Private helper function that calls goTo with the first destination node's index
     *
     * @param destination to go to
     *
     */
    private void goTo(WeightedGraph.Node destination) {
        goTo(destination.getIndex());
    }

    /**
     * Private function that goes to all the destination nodes to complete the pathDone list
     * all while remaining above 15% of battery with the means of recursion
     *
     * @param destinationIndex to go to
     *
     */

    private void goTo(int destinationIndex) {
        LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(currentPos.getIndex(), destinationIndex);

        WeightedGraph.Node destination = path.getLast();
        WeightedGraph.Node rechargeDest = closestRecharge(destination);

        int distance = graph.computeDistanceOfPath(path);
        int distDestRecharge = graph.computeShortestDistance(destination, rechargeDest);
        //totalDist: distance to destination + distance from destination to closest recharge
        int totalDist = distance + distDestRecharge;

        //if battery is below 15 from going from current position to first destination to closest recharge, recharge car
        if (batteryLevel - totalDist < 15) {
            Pair<WeightedGraph.Node, WeightedGraph.Node> pair;
            WeightedGraph.Node recharge;
            pair = closestRechargeToPath(path);
            recharge = pair.getValue();
            addDestinationFirst(recharge);

            goTo(recharge); //goTo closest recharge on path
                            //recursive call until distance short enough for battery

            //recharge once arrived to a recharge node
            if(batteryLevel != 100){
                recharge();
                //update path from recharge
                path = graph.plusCourtChemin(currentPos.getIndex(), destinationIndex);
            }
        }

        // (if battery is above 15) AND
        // ((destination node variable is next in destinations list attribute) OR (battery is not full)),
        // then go to destination node variable
        if (batteryLevel - totalDist >= 15 &&
                (destinations.getFirst().getIndex() == destination.getIndex() || batteryLevel != 100)) {
            batteryLevel -= distance;
            for(Customer customer : customersOnBoard){
                customer.time -= distance;
            }
            for(Customer customer : customers){
                customer.time -= distance;
            }
            for(WeightedGraph.Node node : path){
                if(!pathToDo.getFirst().equalsTo(pathDone.getLast())) {
                    pathDone.addLast(pathToDo.poll());
                    printPath(pathDone.getLast().getIndex(), "path");
                }
                else
                    pathToDo.poll();
            }
            for(WeightedGraph.Node node : pathToDo){
                node.setDistance(node.getDistance() - distance);
            }
            currentPos = destinations.poll();
        }
    }

    static class Customer {
        //customer's initial position
        private WeightedGraph.Node source;
        //customer's desired arrival point
        private WeightedGraph.Node destination;
        //customer's deadline time counting starting at when the driver is spawned
        private Integer time;
        //number of the client in ascending order from requetes.txt
        private int index;

        public Customer(int index, WeightedGraph.Node source, WeightedGraph.Node destination, Integer time) {
            this.index = index;
            this.destination = destination;
            this.source = source;
            this.time = time;
        }
    }
}