package TP1;

import javafx.util.Pair;

import java.io.FileNotFoundException;
import java.util.*;

public class Driver {
    private Integer batteryLevel;
    private Queue<Customer> customers;
    private Queue<Customer> customersOnBoard;
    private WeightedGraph graph;
    private WeightedGraph.Node position;
    private LinkedList<WeightedGraph.Node> pathToDo;
    private LinkedList<WeightedGraph.Node> destinations;
    private LinkedList<WeightedGraph.Node> pathDone;
    private String output = "Trajet : \n";

    public Driver(String graphFileName, String requeteFileName) throws FileNotFoundException {
        batteryLevel = 100;
        customers = new ArrayDeque<>();
        customersOnBoard = new ArrayDeque<>();
        graph = new WeightedGraph();
        graph.createGraph(graphFileName);
        initialiseDriver(requeteFileName);
        pathToDo = new LinkedList<>();
        destinations = new LinkedList<>();
        pathDone = new LinkedList<>();
    }

    /**
     * Public function that generates the customers recursively
     *
     * @param fileName information originating from txt file, in which each line represents either
     *                         information regarding the node, or information regarding adjacentNodes
     */
    public void initialiseDriver(String fileName) throws FileNotFoundException {
        List<String> customerInformation = GeneralFunctions.readFile(fileName);
        initialiseDriver(customerInformation, 0);
    }

    /**
     * Private helper function that recursively process information generated by reading a text file and creates nodes, or
     * updates adjacentNodes attributes depending on the information read
     *
     * @param customerInformation list of either information pertaining to the creation of the node (index, hasBorne; size = 2)
     *                         or information pertaining to adjacentNodes (node, weight)
     *
     * @param lineNumber index of information
     */
    private void initialiseDriver(List<String> customerInformation, int lineNumber) {
        Map<Integer, WeightedGraph.Node> nodes = graph.getNodes();

        if (lineNumber == customerInformation.size()) {
            return;
        }
        String[] infoLine = customerInformation.get(lineNumber).split(",");
        if (infoLine.length == 1) { //first line of the txt file that contains the position of the driver
            position = nodes.get(Integer.parseInt(infoLine[0]));
            initialiseDriver(customerInformation, lineNumber + 1);
        }
        else if (infoLine.length == 4) {
            int index = Integer.parseInt(infoLine[0]); //number of the client
            WeightedGraph.Node sourceNode = nodes.get(Integer.parseInt(infoLine[1])); //node where the client is at
            WeightedGraph.Node destinationNode = nodes.get(Integer.parseInt(infoLine[2])); //node where the client wants to go
            int minutesWeight = Integer.parseInt(infoLine[3]); //time limit to get there
            Customer customer = new Customer(index, sourceNode, destinationNode, minutesWeight);
            customers.add(customer);
            initialiseDriver(customerInformation, lineNumber + 1);
        }
        else {
            initialiseDriver(customerInformation, lineNumber + 1);
        }
    }


    /**
     * Public function that finds the shortest path to serve as many customers in their respective time limit
     * all while maintaining a battery percentage of over 15%
     *
     * @return String of shortest path
     */

    public String traiterRequetes() {
        while(customers.size() > 0 || !customersOnBoard.isEmpty()){
            queueCustomersDestination();
            if(!destinations.isEmpty())
                nextDestination(); //move next node
        }
        output += "Fin du trajet";
        updateTotalDistances();
        return output;
    }

    /**
     * Public function that calculates the total distance of the path followed by the driver to serve
     * all the customers
     *
     */

    public void updateTotalDistances(){
        Iterator<WeightedGraph.Node> itr = pathDone.iterator();
        WeightedGraph.Node current, prev = null;
        int distance = 0;

        while(itr.hasNext()){
            current = itr.next();
            if(current.getBorne() && prev != null) {
                current.setDistance(prev.getDistance());
                continue;
            }
            if (prev != null) {
                distance += graph.computeShortestDistance(prev, current);
                current.setDistance(distance);
            }
            prev = current;
        }
        output += "\n \n Distance totale : " + pathDone.getLast().getDistance();
    }

    /**
     * Public function that adds path information to output string
     *
     * @param index corresponds to either the index of the customer or of the node
     * @param state according to state, printPath adds the appropriate string to output
     *
     */

    public void printPath(int index, String state) {
        switch (state) {
            case "path" :
                output += index + " -> ";
                break;
            case "recharge" :
                output += "\n Recharge ->\n";
                break;
            case "dropoff":
                output += "\n Debarquement client #" + index + " -> \n ";
                break;
        }
    }

    /**
     * Public function that updates all attributes including destinations, nodes distance and pathToDo
     * and adds the node to destinations list at the last position
     *
     * @param destination node to be added last in destinations list
     */
    public void addDestinationLast(WeightedGraph.Node destination) {
        if(!destinations.isEmpty()) {
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(destinations.getLast(), destination);
            destinations.addLast(destination);

            Integer latestDistance = pathToDo.getLast().getDistance();
            for (WeightedGraph.Node node : path) {
                node.setDistance(node.getDistance() + latestDistance);
                pathToDo.addLast(new WeightedGraph.Node(node));
            }
        }
        else {
            destinations.addLast(destination);
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(position, destination);
            pathToDo.addAll(path);
        }
    }

    /**
     * Public function that updates all attributes including destinations, nodes distance, pathToDo related to destinations
     * and adds the node to destinations list at the last position
     *
     * @param destination node to be added first in destinations list
     */
    public void addDestinationFirst(WeightedGraph.Node destination) {
        if(destination.getIndex() == destinations.getFirst().getIndex())
            return;
        if(!destinations.isEmpty()) {
            LinkedList<WeightedGraph.Node> normalPath = graph.plusCourtChemin(position, destinations.getFirst());
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(position, destination);
            LinkedList<WeightedGraph.Node> pathBack = graph.plusCourtChemin(destination, destinations.getFirst());

            destinations.addFirst(destination);

            //Remove nodes
            for(WeightedGraph.Node node : normalPath){
                pathToDo.remove();
            }

            //Distance to add to path
            Integer distanceToAdd = path.getLast().getDistance() + pathBack.getLast().getDistance();
            Integer distanceToRemove = normalPath.getLast().getDistance();
            Iterator<WeightedGraph.Node> itrBack = pathBack.descendingIterator();

            for (WeightedGraph.Node node : pathBack) {
                node.setDistance(node.getDistance() + path.getLast().getDistance());
            }
            for (WeightedGraph.Node node : pathToDo) {
                node.setDistance(node.getDistance() + distanceToAdd - distanceToRemove);
            }
            while(itrBack.hasNext()){
                WeightedGraph.Node node = itrBack.next();
                pathToDo.addFirst(node);
            }
            Iterator<WeightedGraph.Node> itr = path.descendingIterator();
            while(itr.hasNext()){
                WeightedGraph.Node node = itr.next();
                pathToDo.addFirst(node);
            }
        }
        else {
            destinations.addFirst(destination);
            LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(position, destination);
            path.poll();
            pathToDo.addAll(path);
        }
    }


    /**
     * Public function that determines a detour path to a recharging station on path
     *
     * @param path path to find detour on
     * @return DetourPath as LinkedList
     */

    public Pair<LinkedList<WeightedGraph.Node>, LinkedList<WeightedGraph.Node>> detourPath(LinkedList<WeightedGraph.Node> path){
        Pair<WeightedGraph.Node, WeightedGraph.Node> pair = closestRechargeOnPath(path);
        WeightedGraph.Node prev = position, fork = pair.getKey();
        WeightedGraph.Node rechargeNode = pair.getValue();
        LinkedList<WeightedGraph.Node> forkPath, returnPath = null, detour;

        if(path.contains(fork))
            returnPath = graph.plusCourtChemin(rechargeNode, path.getLast());

        forkPath = graph.plusCourtChemin(prev, rechargeNode);
        detour = forkPath;
        int distanceToRecharge = graph.computeDistanceOfPath(forkPath);
        for(WeightedGraph.Node node : returnPath){
            node.setDistance(node.getDistance() + distanceToRecharge);
            detour.addLast(node);
        }

        Pair<LinkedList<WeightedGraph.Node>, LinkedList<WeightedGraph.Node>> pairToReturn;
        pairToReturn = new Pair<>(forkPath, returnPath);

        return pairToReturn;
    }

    /**
     * Public function that adds destinations of customers on board considering
     * time effectiveness, the car's battery and serving as many customers as possible
     *
     * @return void
     */
    public void queueCustomersDestination() {

        Customer firstCustomer = customersOnBoard.peek();

        //if we're at the customers destination, drop off
        while(!customersOnBoard.isEmpty() &&
                firstCustomer.destination.getIndex() == position.getIndex()) {
            dropOff();
            firstCustomer = customersOnBoard.peek();
        }

        //if 4 customersOnBoard, return
        if(customersOnBoard.size() >= 4){
            return;
        }

        //if not 4 customersOnBoard, try to fill customersOnBoard
        while (pickUp() && customersOnBoard.size() < 4) { }

        //if no more customers to pick up, return
        if(customers.isEmpty())
            return;

        //if nowhere to go, get next customer
        if(destinations.isEmpty()) {
            if(pathDone.isEmpty() || !pathDone.getLast().equalsTo(position)) {
                pathDone.add(position);
                printPath(position.getIndex(), "path");
            }
            addDestinationLast(customers.peek().source);
        }

        //Decision tree :
        /*
         * 1.customersOnBoard don't have time to pick up anyone without recharge
         * => drive
         * 2.customersOnBoard don't have time to pick up anyone with recharge
         * => drive
         * 3.customersOnBoard have time, but it isn't efficient to pick up before next destination
         * => drive
         * 4.customersOnBoard have time and it is efficient to pick up before next destination
         * => add pickUp spot as next destination
         *
         *  In other words : if(4){ add pick up} else {drive}
         *  check fork before next destination
         *  check efficiency
         *  check if recharges?
         *  ->
         *  check latestCustomer's time considering recharge
         *  check if nextCustomer's time enough for currentPath
         */

        Customer nextCustomer = customers.peek();

        /*verifying that forkSourceNode is before the first destination in pathToDo */

        //forkSourceNode: closest node on pathToDo to the next customer's current position
        WeightedGraph.Node forkSourceNode = closestNodeOnPath(nextCustomer.source);

        //currentPath: adding all of pathToDo's nodes to currentPath up until we find the destinations node
        LinkedList<WeightedGraph.Node> currentPath = new LinkedList<>();
        WeightedGraph.Node node = null;

        Iterator<WeightedGraph.Node> itr = pathToDo.iterator();
        while(itr.hasNext()){
            node = itr.next();
            if(node.getIndex() != destinations.getFirst().getIndex()) {
                currentPath.addLast(node);
            } else {
                break;
            }
        }

        //if forkSourceNode is not in currentPath, then it's placed after the first destination, return
        if(!currentPath.contains(forkSourceNode))
            return;


        /*verify that the forkPath is shorter than the originalPath*/

        //normalPath: nodes of shortest path between driver's current position and the first destination node
        LinkedList<WeightedGraph.Node> normalPath = graph.plusCourtChemin(position, destinations.getFirst());
        //classicPath: nodes of shortest path between nextCustomer's current position and his destination node
        LinkedList<WeightedGraph.Node> classicPath = graph.plusCourtChemin(nextCustomer.source, nextCustomer.destination);
        //pickUpPath: nodes of shortest path between the last destination node and nextCustomer's current position
        LinkedList<WeightedGraph.Node> pickUpPath = graph.plusCourtChemin(destinations.getLast(), nextCustomer.source);

        //forkSourcePath: nodes of shortest path between forkSourceNode and nextCustomer's current position
        LinkedList<WeightedGraph.Node> forkSourcePath = graph.plusCourtChemin(forkSourceNode, nextCustomer.source);
        //forkDestinationPath: nodes of shortest path between forkSourceNode and nextCustomer's destination
        LinkedList<WeightedGraph.Node> forkDestinationPath = graph.plusCourtChemin(destinations.getLast(), nextCustomer.destination);
        //forkReturnPath: nodes of shortest path between nextCustomer's current position and the first destination node
        LinkedList<WeightedGraph.Node> forkReturnPath = graph.plusCourtChemin(nextCustomer.source, destinations.getFirst());

        Integer normalDistance = normalPath.getLast().getDistance();
        Integer classicDistance = classicPath.getLast().getDistance();
        Integer pickUpDistance = pickUpPath.getLast().getDistance();

        Integer forkSourceDistance = forkSourcePath.getLast().getDistance();
        Integer forkReturnDistance = forkReturnPath.getLast().getDistance();
        Integer forkDestinationDistance = forkDestinationPath.getLast().getDistance();

        Integer forkDistance = forkSourceDistance + forkReturnDistance + forkDestinationDistance;
        Integer originalDistance = normalDistance + classicDistance + pickUpDistance;

        Integer changeDistance = forkDistance - originalDistance;

        //if the original distance is shorter than the fork distance, return
        if(changeDistance > 0)
            return;


        /*verify when recharge is needed*/

        LinkedList<WeightedGraph.Node> destinationsCopy, destinationPath;
        destinationsCopy = new LinkedList<>(destinations);

        WeightedGraph.Node prev = position, next;

        Integer batteryCopy = batteryLevel;
        Integer timeForRecharges = 0;

        int destinationsSize = destinations.size();
        for(int i = 1 ; i < destinationsSize; i++){
            next = destinationsCopy.poll();
            destinationPath = graph.plusCourtChemin(prev, next);
            if(batteryCopy.compareTo(destinationPath.getLast().getDistance()) < 15){ //need to charge
                destinations.add(destinations.indexOf(next), closestRechargeOnPath(destinationPath).getValue());

                Pair<LinkedList<WeightedGraph.Node>, LinkedList<WeightedGraph.Node>> detourPair = detourPath(destinationPath);
                LinkedList<WeightedGraph.Node> forkPath = detourPair.getKey();
                LinkedList<WeightedGraph.Node> returnPath = detourPair.getValue();

                int distanceBack = returnPath.getLast().getDistance();

                int changeInDistance = forkPath.getLast().getDistance()
                        + returnPath.getLast().getDistance() - currentPath.getLast().getDistance();

                batteryCopy = 100;
                batteryCopy -= distanceBack;
                //10 for recharge, time for detour - time normal
                timeForRecharges += (10 + changeInDistance);
            }
            else {
                batteryCopy -= (next.getDistance() - prev.getDistance());
            }
            prev = next;
        }

        Integer totalTimeAdded = pathToDo.getLast().getDistance() + changeDistance + timeForRecharges;
        Integer totalTimeForNext = totalTimeAdded - forkSourceDistance; //minus time to get to source

        //if time to get to next customer's goes over his time limit, return
        if(nextCustomer.time.compareTo(totalTimeForNext) < 0)
            return;

        //if time to get to next customer on board goes over his time limit, return
        for(Customer customer : customersOnBoard){
            if(customer.time.compareTo(totalTimeAdded) < 0)
                return;
        }

        //if passed all test, add pick up
        addDestinationFirst(nextCustomer.source);
    }

    /**
     * Finds closest recharge on path
     *
     * @param path path of the nodes
     * @return pair of fork node to get to recharge node and recharge node closest to the path
     */

    public Pair<WeightedGraph.Node, WeightedGraph.Node> closestRechargeOnPath(LinkedList<WeightedGraph.Node> path) {
        //Current position
        if(position.getBorne())
            return new Pair<WeightedGraph.Node, WeightedGraph.Node>(position, position);

        WeightedGraph.Node closestRechargeOverall = closestRecharge(position);
        WeightedGraph.Node forkNode = null;
        WeightedGraph.Node closestRecharge;
        int closestDistance = graph.computeShortestDistance(position, closestRechargeOverall);

        for(WeightedGraph.Node node : path){
            closestRecharge = closestRecharge(node);
            int distanceToRecharge = graph.computeShortestDistance(node, closestRecharge);
            if(node.getDistance() + distanceToRecharge + 15 > batteryLevel) //stop when too far for the battery
                break;
            if(distanceToRecharge < closestDistance){
                closestDistance = distanceToRecharge;
                closestRechargeOverall = closestRecharge;
                forkNode = node;
            }
        }
        return new Pair<WeightedGraph.Node, WeightedGraph.Node>(forkNode, closestRechargeOverall);
    }

    /**
     *
     * @param source source node
     * @return recharge node
     *
     */
    public WeightedGraph.Node closestRecharge(WeightedGraph.Node source) {
        return closestRecharge(source.getIndex());
    }

    /**
     *
     * @param indexSource index of the source node
     * @return recharge node
     *
     */
    public WeightedGraph.Node closestRecharge(int indexSource) {
        LinkedList<WeightedGraph.Node> shortestPath = null;
        int shortestDistance;
        shortestDistance = Integer.MAX_VALUE;
        Map<Integer, WeightedGraph.Node> nodeMap = graph.getNodes();

        for(Map.Entry<Integer, WeightedGraph.Node> nodeEntry : nodeMap.entrySet()){
            WeightedGraph.Node node = nodeEntry.getValue();
            if(node.getBorne()){
                if(graph.computeShortestDistance(indexSource, node.getIndex()) < shortestDistance){
                    shortestPath = graph.plusCourtChemin(indexSource, node.getIndex());
                    shortestDistance = graph.computeDistanceOfPath(shortestPath);
                }
            }
        }

        return shortestPath.getLast();
    }

    /**
     * Finds the closest node on path from node passed
     *
     * @param destination node which we want to go to
     * @return node closest on path to destination
     */
    public WeightedGraph.Node closestNodeOnPath(WeightedGraph.Node destination) {
        WeightedGraph.Node forkNode = null;
        int closestDistance = Integer.MAX_VALUE;
        for(WeightedGraph.Node node : pathToDo){
            int distanceToNode = graph.computeShortestDistance(node, destination);
            if(distanceToNode < closestDistance){
                closestDistance = distanceToNode;
                forkNode = node;
            }
        }
        return forkNode;
    }

    /**
     * Recharge la batterie de la voiture a 100%
     *
     */

    public void recharge() {
        if(position.getBorne()){
            printPath(position.getIndex(), "recharge");
            batteryLevel = 100;
            for (Customer customer : customersOnBoard){
                //+10 minutes au trajet
                customer.time -= 10;
            }
        }
    }


    /**
     * Removes a customer to the customersOnBoard queue only if
     * the customer is already at the driver's position
     *
     * @return void
     *
     */
    public void dropOff(){
        Customer customer = customersOnBoard.peek();
        if(customer != null && customer.destination.getIndex() == position.getIndex()){
            printPath(customer.index, "dropoff");
            customersOnBoard.remove(customer);
        }
    }

    /**
     * Adds a customer to the customersOnBoard queue only if
     * the customer is already at the driver's position
     *
     * @return boolean of whether a customer was picked up or not
     */
    public boolean pickUp() {
        if(!customers.isEmpty()) {
            Customer nextCustomer = customers.peek();
            if (position.getIndex() == nextCustomer.source.getIndex()) {
                if(!customersOnBoard.isEmpty()) {
                    Customer lastCustomer = null;
                    for (Customer customer : customersOnBoard) {
                        lastCustomer = customer;
                    }
                    if (lastCustomer.source.equalsTo(position)) {
                        pathDone.addLast(position);
                        printPath(position.getIndex(), "path");
                    }
                }
                customersOnBoard.add(customers.poll());
                addDestinationLast(nextCustomer.destination);
                return true;
            }
        }
        return false;
    }

    public void nextDestination() {
        goTo(destinations.getFirst());
    }

    /**
     * Driver class for recursive function
     *
     * @param destination to go to
     * @return void
     */
    private void goTo(WeightedGraph.Node destination) {
        goTo(destination.getIndex());
    }

    private void goTo(int destinationIndex) {
        LinkedList<WeightedGraph.Node> path = graph.plusCourtChemin(position.getIndex(), destinationIndex);
        int distance = graph.computeDistanceOfPath(path);
        WeightedGraph.Node destination = path.getLast();
        WeightedGraph.Node rechargeDest = closestRecharge(destination);
        int distDestRecharge = graph.computeShortestDistance(destination, rechargeDest);
        //distance to destination + distance from destination to closest recharge
        int totalDist = distance + distDestRecharge;
        if (batteryLevel - totalDist < 15) { //if not enough battery
            Pair<WeightedGraph.Node, WeightedGraph.Node> pair;
            WeightedGraph.Node recharge;
            pair = closestRechargeOnPath(path);
            recharge = pair.getValue();
            addDestinationFirst(recharge);
            goTo(recharge); //goTo closest recharge on path
            //recursive call until distance short enough for battery
            if(batteryLevel != 100){ //if first recharge
                recharge();
                //update path from recharge
                path = graph.plusCourtChemin(position.getIndex(), destinationIndex);
            }
        }
        if (batteryLevel - totalDist >= 15 && //check not battery too low
                (destinations.getFirst().getIndex() == destination.getIndex() || batteryLevel != 100)
            //destination is next in destinations or battery not full
        ) {
            batteryLevel -= distance;
            for(Customer customer : customersOnBoard){
                customer.time -= distance;
            }
            for(WeightedGraph.Node node : path){
                if(!pathToDo.getFirst().equalsTo(pathDone.getLast())) {
                    pathDone.addLast(pathToDo.poll());
                    printPath(pathDone.getLast().getIndex(), "path");
                }
                else
                    pathToDo.poll();
            }
            for(WeightedGraph.Node node : pathToDo){
                node.setDistance(node.getDistance() - distance);
            }
            position = destinations.poll();//destination;
        }
    }

    static class Customer {
        private WeightedGraph.Node source;
        private WeightedGraph.Node destination;
        private Integer time;
        private int index;

        public Customer(int index, WeightedGraph.Node source, WeightedGraph.Node destination, Integer time) {
            this.index = index;
            this.destination = destination;
            this.source = source;
            this.time = time;
        }
    }
}