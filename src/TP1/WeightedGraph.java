package TP1;

import java.io.FileNotFoundException;
import java.util.*;

public class WeightedGraph {

    /**
     * Integer : ID of Node
     * Node : Object Node
     */
    private Map<Integer, Node> nodes;

    public WeightedGraph () {
        nodes = new HashMap<>();
    }

    public Map<Integer, Node> getNodes(){ return nodes; }

    public void addNode(Node newNode) {
        nodes.put(newNode.index, newNode);
    }


    /**
     * Public function that generates the graph recursively
     *
     * @param fileName information originating from txt file, in which each line represents either
     *                         information pertaining to node, or information pertaining to adjacentNodes
     */
    public void createGraph(String fileName) throws FileNotFoundException {
        List<String> graphInformation = GeneralFunctions.readFile(fileName);
        createGraph(graphInformation, 0);
    }

    /**
     * Private helper function that recursively process information generated by reading a text file and creates nodes, or
     * updates adjacentNodes attributes depending on the information read
     *
     * @param graphInformation list of either information pertaining to the creation of the node (index, hasBorne; size = 2)
     *                         or information pertaining to adjacentNodes (node, weight)
     * @param lineNumber index of information
     *
     */
    private void createGraph(List<String> graphInformation, int lineNumber) {
        if (lineNumber == graphInformation.size()) {
            return;
        }
        String[] infoLine = graphInformation.get(lineNumber).split(",");
        if (infoLine.length == 2) {
            boolean hasBorne = !infoLine[1].equals("0");
            int nodeId = Integer.parseInt(infoLine[0]);
            addNode(new Node(nodeId, hasBorne));
            createGraph(graphInformation, lineNumber + 1);
        }
        else if (infoLine.length == 3) {
            Node sourceNode = nodes.get(Integer.parseInt(infoLine[0]));
            Node destinationNode = nodes.get(Integer.parseInt(infoLine[1]));
            int minutesWeight = Integer.parseInt(infoLine[2]);
            sourceNode.addAdjacentNode(destinationNode, minutesWeight);
            destinationNode.addAdjacentNode(sourceNode, minutesWeight);
            createGraph(graphInformation, lineNumber + 1);
        }
        else {
            createGraph(graphInformation, lineNumber + 1);
        }
    }

    /**
     * Public function that prints the weighted graph in order (Current Node, boolean containsRecharge, and list of neighbors)
     *
     * @return String of the graph
     *
     */
    public String printGraph() {
        String graph = "Carte : ";
        for (Map.Entry<Integer, Node> entry : nodes.entrySet()) {
            Node currentNode = entry.getValue();
            graph = graph + "Node " + entry.getKey() + ", Has recharge : " + currentNode.getBorne() +"\n";
            for(Map.Entry<Node, Integer> pair: currentNode.adjacentNodes.entrySet()){
                graph = graph + "Neighbor: Node " + pair.getKey().index + ", Weight: " + pair.getValue() + ", ";
            }
            graph += "\n";
        }
        return graph;
    }

    /**
     * Public function that prints the shortest trajectory
     *
     * @return String of trajectory
     *
     */
    public String printTrajectory(int source, int destination) {
        String trajectory = "Plus court chemin: \n";
        LinkedList<Node> chemin = plusCourtChemin(source, destination);

        trajectory += "Trajet : ( ";
        if(source != destination)
            trajectory += source + " ";
        for (Node node : chemin) {
            trajectory = trajectory + node.index + " ";
        }
        trajectory += ")";
        return trajectory;
    }

    /**
     * Public function calls plusCourtChemin with the node's indexes
     *
     * @param source origin point
     * @param destination destination point
     * @return shortestPath A list of nodes that represents the shortest path between the source node
     *                      and the destination node
     */

    public LinkedList<Node> plusCourtChemin(Node source, Node destination) {
        return plusCourtChemin(source.getIndex(), destination.getIndex());
    }


    /**
     * Public helper function that implements Dijkstra's shortest path algorithm. Computes the shortest path between
     * two nodes in a graph
     *
     * @param indexSource origin point
     * @param indexDestination destination point
     * @return shortestPath A list of nodes that represents the shortest path between the source node
     *                      and the destination node
     */

    public LinkedList<Node> plusCourtChemin(int indexSource, int indexDestination) {
        resetGraph();
        Queue<Node> nodesToProcess = new PriorityQueue<>(new NodeComparator());
        Set<Node> visitedNodes = new HashSet<>();
        LinkedList<Node> shortestPath = new LinkedList<>();

        Node sourceNode = nodes.get(indexSource);
        Node destinationNode = nodes.get(indexDestination);
        sourceNode.setDistance(0);
        nodesToProcess.add(sourceNode);
        visitedNodes.add(sourceNode);

        if(sourceNode == destinationNode){
            shortestPath.add(sourceNode);
            return shortestPath;
        }

        while (nodesToProcess.peek() != destinationNode && !nodesToProcess.isEmpty()) {
            Node currentNode = nodesToProcess.poll();
            Integer currentDistance = currentNode.getDistance();
            for (Map.Entry<Node, Integer> neighboringNode : currentNode.adjacentNodes.entrySet()) {
                Node neighbor = neighboringNode.getKey();
                Integer distanceToNeighbor = neighboringNode.getValue();
                if (currentDistance + distanceToNeighbor < neighbor.getDistance()) {
                    neighbor.setDistance(currentDistance + distanceToNeighbor);
                    neighbor.setPathFrom(currentNode);
                }
                if (!visitedNodes.contains(neighbor)) {
                    nodesToProcess.add(neighbor);
                }
                visitedNodes.add(neighbor);
            }
        }

        //new nodes so attributes not changed by mistake later on
        Node previousNodeInPath = new Node (destinationNode);
        while (previousNodeInPath.getPathFrom() != null) {
            shortestPath.addFirst(previousNodeInPath);
            previousNodeInPath = new Node (previousNodeInPath.getPathFrom());
        }

        return shortestPath;
    }

    /**
     * Public function that calculates the cost of distances between every node in the shortest path
     *
     * @param path The list containing the nodes in the shortest between point A and B
     * @return totalDistance the cost in distance for going going from point A and point B
     */

    public int computeDistanceOfPath(LinkedList<Node> path) {
        return path.getLast().getDistance();
    }

    /**
     * Public function that calculates the cost of distances between two nodes with index
     *
     * @param indexSource index of the source node
     * @param indexDestination index of the destination node
     * @return totalDistance the cost in distance for going going from point A and point B
     */

    public int computeShortestDistance(int indexSource, int indexDestination) {
        LinkedList<Node> path = plusCourtChemin(indexSource, indexDestination);
        return path.getLast().getDistance();
    }

    /**
     * Public function that calculates the cost of distances between two nodes
     *
     * @param source source node
     * @param destination destination node
     * @return totalDistance the cost in distance for going going from point A and point B
     */

    public int computeShortestDistance(Node source, Node destination) {
        return computeShortestDistance(source.getIndex(), destination.getIndex());
    }

    /**
     * Public function that resets the distance attribute for every node in our graph to "infinity"
     * and the pathFrom attribute
     *
     */
    private void resetGraph() {
        for (Map.Entry<Integer, Node> node : nodes.entrySet()) {
            node.getValue().setDistance(Integer.MAX_VALUE);
            node.getValue().setPathFrom(null);
        }
    }

    /**
     * Public function that resets the distance attribute for every node in our graph to "infinity"
     * and the pathFrom attribute
     *
     * @return String
     *
     */
    public String traiterRequetes() throws FileNotFoundException {
        Driver driver = new Driver("arrondissements.txt", "requetes.txt");
        return driver.traiterRequetes();
    }


    static class Node {
        private int index;
        private boolean hasBorne;

        private Map<Node,Integer> adjacentNodes;
        private Integer distance = Integer.MAX_VALUE;
        private Node pathFrom = null;

        public Node (Node node){
            index = node.index;
            hasBorne = node.hasBorne;
            distance = node.distance;
            adjacentNodes = node.adjacentNodes;
            pathFrom = node.pathFrom;
        }

        public Node (int index, boolean hasBorne) {
            this.index = index;
            this.hasBorne = hasBorne;
            distance = 0;
            adjacentNodes = new HashMap<>();
        }

        public void addAdjacentNode(Node node,Integer weight){
            adjacentNodes.put(node,weight);
        }

        public Integer getDistance() {
            return this.distance;
        }

        public Node getPathFrom() {
            return this.pathFrom;
        }

        public boolean getBorne() { return this.hasBorne; }

        public int getIndex() { return this.index; }

        public void setDistance(Integer distance) {
            this.distance = distance;
        }

        public void setPathFrom(Node sourceNode) {
            this.pathFrom = sourceNode;
        }

        public boolean equalsTo(Node compareNode) { return index == compareNode.index; }

    }

    static class NodeComparator implements Comparator<Node>{

        // Overriding compare() method of Comparator
        // for ascending order of weight
        public int compare(Node firstNode, Node secondNode) {
            return firstNode.distance.compareTo(secondNode.distance);
        }
    }
}