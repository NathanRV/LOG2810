package TP1;

import java.io.FileNotFoundException;
import java.util.*;

public class WeightedGraph {

    /**
     * Integer : ID of Node
     * Node : Object Node
     */
    Map<Integer, Node> nodes;

    public WeightedGraph () {
        nodes = new HashMap<>();
    }


    /**
     * Public function that generates the graph recursively
     *
     * @param fileName information originating from txt file, in which each line represents either
     *                         information pertaining to node, or information pertaining to adjacentNodes
     */
    public void createGraph(String fileName) throws FileNotFoundException {
        List<String> graphInformation = GeneralFunctions.readFile(fileName);
        createGraph(graphInformation, 0);
    }

    /**
     * Private helper function that recursively process information generated by reading a text file and creates nodes, or
     * updates adjacentNodes attributes depending on the information read
     *
     * @param graphInformation list of either information pertaining to the creation of the node (index, hasRecharge; size = 2)
     *                         or information pertaining to adjacentNodes (node, weight)
     *
     * @param lineNumber index of information
     */
    private void createGraph(List<String> graphInformation, int lineNumber) {
        if (lineNumber == graphInformation.size()) {
            return;
        }
        String[] infoLine = graphInformation.get(lineNumber).split(",");
        if (infoLine.length == 2) {
            boolean hasRecharge = !infoLine[1].equals("0");
            int nodeId = Integer.parseInt(infoLine[0]);
            addNode(new Node(nodeId, hasRecharge));
            createGraph(graphInformation, lineNumber + 1);
        }
        else if (infoLine.length == 3) {
            Node sourceNode = nodes.get(Integer.parseInt(infoLine[0]));
            Node destinationNode = nodes.get(Integer.parseInt(infoLine[1]));
            int minutesWeight = Integer.parseInt(infoLine[2]);
            sourceNode.addAdjacentNode(destinationNode, minutesWeight);
            destinationNode.addAdjacentNode(sourceNode, minutesWeight);
            createGraph(graphInformation, lineNumber + 1);
        }
        else {
            createGraph(graphInformation, lineNumber + 1);
        }
    }

    /**
     * Prints the weighted graph in order (Current Node, boolean containsRecharge, and list of neighbors)
     */
    public void printGraph() {
        for (Map.Entry<Integer, Node> entry : nodes.entrySet()) {
            Node currentNode = entry.getValue();
            System.out.print("(Node " + entry.getKey() + ", Has recharge : " + currentNode.hasRecharge + " (");
            for(Map.Entry<Node, Integer> pair: currentNode.adjacentNodes.entrySet()){
                System.out.print("(Neighbor: Node " + pair.getKey().index + ", Weight: " + pair.getValue() + "),");
            }
            System.out.print(")))");
            System.out.println();
        }
    }

    /**
     * Prints the shortest trajectory
     */
    public void printTrajectory(int source, int destination) {

        Collection<Integer> chemin = plusCourtChemin(source, destination);

        System.out.print("Trajet : ( ");
        for (Integer index : chemin) {
            System.out.print(index + " ");
        }
        System.out.print(")");
    }

    public void addNode(Node newNode) {
        nodes.put(newNode.index, newNode);
    }

    public Map.Entry<Node, Integer> nextNode(Node nodeToCheck){
        Integer min = null;
        Node next = null;
        for(Map.Entry<Node, Integer> entry : nodeToCheck.adjacentNodes.entrySet()){
            if( min == null || min.compareTo(entry.getValue())>0 ){
                min = entry.getValue();
                next = entry.getKey();
            }
        }

        return Map.entry(next, min);
    }

    public Collection<Integer> plusCourtChemin(int indexSource, int indexDestination) {

        Node source = nodes.get(indexSource);
        Node destination = nodes.get(indexDestination);

        Queue<Node> nodesToCheck = new PriorityQueue<Node>(20, new NodeComparator());
        nodesToCheck.add(source);
        source.distance=0;

        Map<Node, Integer> nodesChecked = new HashMap<>();
        nodesChecked.put(source, source.distance);

        Node prev = source;
        Map.Entry<Node, Integer> edge;
        Node next;
        Integer distance;
        //tant que pas atteint destination ou qu'il ne reste plus de noeuds à verifier
        while (nodesToCheck.size() > 0 && prev != destination){

            edge = nextNode(nodesToCheck.element());      //Le plus petit arc
            next = edge.getKey();

            //trouver noeud connecté à celui ci O(n^2), moyen d'optimiser?
            for(Node node : nodesChecked.keySet()){
                for(Map.Entry<Node, Integer> pair : node.adjacentNodes.entrySet()){
                    if(pair.getKey() == edge.getKey() && pair.getValue().compareTo(edge.getValue())==0){
                        prev = node;
                        break;
                    }
                }
            }

            distance = prev.adjacentNodes.get(next); //distance entre les deux

            if(prev.distance + distance < next.distance){
                next.distance = prev.distance + distance; //Ajout distance

                next.trajet.addAll(prev.trajet); //Ajout trajet jusqu'à date
                next.trajet.add(prev.index);           //Ajout du noeud précédent
            }

            if(!nodesChecked.containsKey(next)){
                nodesToCheck.add(next);
            }
            nodesChecked.put(next, next.distance);
            nodesToCheck.element().adjacentNodes.remove(next);
            if(nodesToCheck.element().adjacentNodes.size()==0){
                nodesToCheck.remove();
            }
        }
        destination.trajet.add(destination.index);
        return destination.trajet;
    }

    public void traiterRequetes(String fileName) {

    }


    static class Node {
        private int index;
        private boolean hasRecharge;

        private Map<Node,Integer> adjacentNodes;
        private Integer distance;
        private Collection<Integer> trajet;

        public Node (int index, boolean hasRecharge) {
            this.index = index;
            this.hasRecharge = hasRecharge;
            adjacentNodes=new HashMap<>();
            distance=Integer.MAX_VALUE;
            trajet = new LinkedList<>();
        }

        public void addAdjacentNode(Node node,Integer weight){
            adjacentNodes.put(node,weight);
        }
    }

    class NodeComparator implements Comparator<Node>{

        // Overriding compare()method of Comparator
        // for ascending order of weight
        public int compare(Node n1, Node n2) {
            Collection<Integer> weightsN1 = n1.adjacentNodes.values();
            Integer min1 = Integer.MAX_VALUE;
            for(Integer weight: weightsN1){
                if(min1 > weight){
                    min1 = weight;
                }
            }

            Integer dist1 = min1 + n1.distance;

            Collection<Integer> weightsN2 = n2.adjacentNodes.values();
            Integer min2 = Integer.MAX_VALUE;
            for(Integer weight: weightsN2){
                if(min2 > weight){
                    min2 = weight;
                }
            }

            Integer dist2 = min2 + n2.distance;

            if (dist1 > dist2)
                return 1;
            else if (dist1 < dist2)
                return -1;
            return 0;
        }
    }
}
